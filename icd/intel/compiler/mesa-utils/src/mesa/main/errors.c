/**
 * \file errors.c
 * Mesa debugging and error handling functions.
 */

/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2007  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */


#include "errors.h"
#include "enums.h"
#include "imports.h"
#include "context.h"
// #include "dispatch.h"  // LunarG REM:
#include "hash.h"
#include "mtypes.h"
#include "version.h"
#include "hash_table.h"

static mtx_t DynamicIDMutex = _MTX_INITIALIZER_NP;
static GLuint NextDynamicID = 1;

/**
 * A namespace element.
 */
struct gl_debug_element
{
   struct simple_node link;

   GLuint ID;
   /* at which severity levels (mesa_debug_severity) is the message enabled */
   GLbitfield State;
};

struct gl_debug_namespace
{
   struct simple_node Elements;
   GLbitfield DefaultState;
};

struct gl_debug_group {
   struct gl_debug_namespace Namespaces[MESA_DEBUG_SOURCE_COUNT][MESA_DEBUG_TYPE_COUNT];
};

/**
 * An error, warning, or other piece of debug information for an application
 * to consume via GL_ARB_debug_output/GL_KHR_debug.
 */
struct gl_debug_message
{
   enum mesa_debug_source source;
   enum mesa_debug_type type;
   GLuint id;
   enum mesa_debug_severity severity;
   GLsizei length;
   GLcharARB *message;
};

/**
 * Debug message log.  It works like a ring buffer.
 */
struct gl_debug_log {
   struct gl_debug_message Messages[MAX_DEBUG_LOGGED_MESSAGES];
   GLint NextMessage;
   GLint NumMessages;
};

struct gl_debug_state
{
   GLDEBUGPROC Callback;
   const void *CallbackData;
   GLboolean SyncOutput;
   GLboolean DebugOutput;

   struct gl_debug_group *Groups[MAX_DEBUG_GROUP_STACK_DEPTH];
   struct gl_debug_message GroupMessages[MAX_DEBUG_GROUP_STACK_DEPTH];
   GLint GroupStackDepth;

   struct gl_debug_log Log;
};

static char out_of_memory[] = "Debugging error: out of memory";

static const GLenum debug_source_enums[] = {
   GL_DEBUG_SOURCE_API,
   GL_DEBUG_SOURCE_WINDOW_SYSTEM,
   GL_DEBUG_SOURCE_SHADER_COMPILER,
   GL_DEBUG_SOURCE_THIRD_PARTY,
   GL_DEBUG_SOURCE_APPLICATION,
   GL_DEBUG_SOURCE_OTHER,
};

static const GLenum debug_type_enums[] = {
   GL_DEBUG_TYPE_ERROR,
   GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR,
   GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR,
   GL_DEBUG_TYPE_PORTABILITY,
   GL_DEBUG_TYPE_PERFORMANCE,
   GL_DEBUG_TYPE_OTHER,
   GL_DEBUG_TYPE_MARKER,
   GL_DEBUG_TYPE_PUSH_GROUP,
   GL_DEBUG_TYPE_POP_GROUP,
};

static const GLenum debug_severity_enums[] = {
   GL_DEBUG_SEVERITY_LOW,
   GL_DEBUG_SEVERITY_MEDIUM,
   GL_DEBUG_SEVERITY_HIGH,
   GL_DEBUG_SEVERITY_NOTIFICATION,
};

/**
 * Handles generating a GL_ARB_debug_output message ID generated by the GL or
 * GLSL compiler.
 *
 * The GL API has this "ID" mechanism, where the intention is to allow a
 * client to filter in/out messages based on source, type, and ID.  Of course,
 * building a giant enum list of all debug output messages that Mesa might
 * generate is ridiculous, so instead we have our caller pass us a pointer to
 * static storage where the ID should get stored.  This ID will be shared
 * across all contexts for that message (which seems like a desirable
 * property, even if it's not expected by the spec), but note that it won't be
 * the same between executions if messages aren't generated in the same order.
 */
static void
debug_get_id(GLuint *id)
{
   if (!(*id)) {
      mtx_lock(&DynamicIDMutex);
      if (!(*id))
         *id = NextDynamicID++;
      mtx_unlock(&DynamicIDMutex);
   }
}

static void
debug_message_store(struct gl_debug_message *msg,
                    enum mesa_debug_source source,
                    enum mesa_debug_type type, GLuint id,
                    enum mesa_debug_severity severity,
                    GLsizei len, const char *buf)
{
   assert(!msg->message && !msg->length);

   msg->message = malloc(len+1);
   if (msg->message) {
      (void) strncpy(msg->message, buf, (size_t)len);
      msg->message[len] = '\0';

      msg->length = len+1;
      msg->source = source;
      msg->type = type;
      msg->id = id;
      msg->severity = severity;
   } else {
      static GLuint oom_msg_id = 0;
      debug_get_id(&oom_msg_id);

      /* malloc failed! */
      msg->message = out_of_memory;
      msg->length = strlen(out_of_memory)+1;
      msg->source = MESA_DEBUG_SOURCE_OTHER;
      msg->type = MESA_DEBUG_TYPE_ERROR;
      msg->id = oom_msg_id;
      msg->severity = MESA_DEBUG_SEVERITY_HIGH;
   }
}
static void
debug_namespace_clear(struct gl_debug_namespace *ns)
{
   struct simple_node *node, *tmp;

   foreach_s(node, tmp, &ns->Elements)
      free(node);
}

/**
 * Get the state of \p id in the namespace.
 */
static bool
debug_namespace_get(const struct gl_debug_namespace *ns, GLuint id,
                    enum mesa_debug_severity severity)
{
   struct simple_node *node;
   uint32_t state;

   state = ns->DefaultState;
   foreach(node, &ns->Elements) {
      struct gl_debug_element *elem = (struct gl_debug_element *) node;

      if (elem->ID == id) {
         state = elem->State;
         break;
      }
   }

   return (state & (1 << severity));
}

/**
 * Return true if the top debug group points to the group below it.
 */
static bool
debug_is_group_read_only(const struct gl_debug_state *debug)
{
   const GLint gstack = debug->GroupStackDepth;
   return (gstack > 0 && debug->Groups[gstack] == debug->Groups[gstack - 1]);
}

/**
 * Free the top debug group.
 */
static void
debug_clear_group(struct gl_debug_state *debug)
{
   const GLint gstack = debug->GroupStackDepth;

   if (!debug_is_group_read_only(debug)) {
      struct gl_debug_group *grp = debug->Groups[gstack];
      int s, t;

      for (s = 0; s < MESA_DEBUG_SOURCE_COUNT; s++) {
         for (t = 0; t < MESA_DEBUG_TYPE_COUNT; t++)
            debug_namespace_clear(&grp->Namespaces[s][t]);
      }

      free(grp);
   }

   debug->Groups[gstack] = NULL;
}

/**
 * Loop through debug group stack tearing down states for
 * filtering debug messages.  Then free debug output state.
 */
static void
debug_destroy(struct gl_debug_state *debug)
{
   while (debug->GroupStackDepth > 0) {
      debug_clear_group(debug);
      debug->GroupStackDepth--;
   }

   debug_clear_group(debug);
   free(debug);
}

/**
 * Returns if the given message source/type/ID tuple is enabled.
 */
static bool
debug_is_message_enabled(const struct gl_debug_state *debug,
                         enum mesa_debug_source source,
                         enum mesa_debug_type type,
                         GLuint id,
                         enum mesa_debug_severity severity)
{
   const GLint gstack = debug->GroupStackDepth;
   struct gl_debug_group *grp = debug->Groups[gstack];
   struct gl_debug_namespace *nspace = &grp->Namespaces[source][type];

   if (!debug->DebugOutput)
      return false;

   return debug_namespace_get(nspace, id, severity);
}

/**
 * 'buf' is not necessarily a null-terminated string. When logging, copy
 * 'len' characters from it, store them in a new, null-terminated string,
 * and remember the number of bytes used by that string, *including*
 * the null terminator this time.
 */
static void
debug_log_message(struct gl_debug_state *debug,
                  enum mesa_debug_source source,
                  enum mesa_debug_type type, GLuint id,
                  enum mesa_debug_severity severity,
                  GLsizei len, const char *buf)
{
   struct gl_debug_log *log = &debug->Log;
   GLint nextEmpty;
   struct gl_debug_message *emptySlot;

   assert(len >= 0 && len < MAX_DEBUG_MESSAGE_LENGTH);

   if (log->NumMessages == MAX_DEBUG_LOGGED_MESSAGES)
      return;

   nextEmpty = (log->NextMessage + log->NumMessages)
      % MAX_DEBUG_LOGGED_MESSAGES;
   emptySlot = &log->Messages[nextEmpty];

   debug_message_store(emptySlot, source, type,
                       id, severity, len, buf);

   log->NumMessages++;
}

/**
 * Lock and return debug state for the context.  The debug state will be
 * allocated and initialized upon the first call.  When NULL is returned, the
 * debug state is not locked.
 */
static struct gl_debug_state *
_mesa_lock_debug_state(struct gl_context *ctx)
{
    return 0;
}

static void
_mesa_unlock_debug_state(struct gl_context *ctx)
{
}

/**
 * Set the integer debug state specified by \p pname.  This can be called from
 * _mesa_set_enable for example.
 */
bool
_mesa_set_debug_state_int(struct gl_context *ctx, GLenum pname, GLint val)
{
   struct gl_debug_state *debug = _mesa_lock_debug_state(ctx);

   if (!debug)
      return false;

   switch (pname) {
   case GL_DEBUG_OUTPUT:
      debug->DebugOutput = (val != 0);
      break;
   case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
      debug->SyncOutput = (val != 0);
      break;
   default:
      assert(!"unknown debug output param");
      break;
   }

   _mesa_unlock_debug_state(ctx);

   return true;
}

/**
 * Query the integer debug state specified by \p pname.  This can be called
 * _mesa_GetIntegerv for example.
 */
GLint
_mesa_get_debug_state_int(struct gl_context *ctx, GLenum pname)
{
   struct gl_debug_state *debug;
   GLint val;

   mtx_lock(&ctx->DebugMutex);
   debug = ctx->Debug;
   if (!debug) {
      mtx_unlock(&ctx->DebugMutex);
      return 0;
   }

   switch (pname) {
   case GL_DEBUG_OUTPUT:
      val = debug->DebugOutput;
      break;
   case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
      val = debug->SyncOutput;
      break;
   case GL_DEBUG_LOGGED_MESSAGES:
      val = debug->Log.NumMessages;
      break;
   case GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH:
      val = (debug->Log.NumMessages) ?
         debug->Log.Messages[debug->Log.NextMessage].length : 0;
      break;
   case GL_DEBUG_GROUP_STACK_DEPTH:
      val = debug->GroupStackDepth;
      break;
   default:
      assert(!"unknown debug output param");
      val = 0;
      break;
   }

   mtx_unlock(&ctx->DebugMutex);

   return val;
}

/**
 * Query the pointer debug state specified by \p pname.  This can be called
 * _mesa_GetPointerv for example.
 */
void *
_mesa_get_debug_state_ptr(struct gl_context *ctx, GLenum pname)
{
   struct gl_debug_state *debug;
   void *val;

   mtx_lock(&ctx->DebugMutex);
   debug = ctx->Debug;
   if (!debug) {
      mtx_unlock(&ctx->DebugMutex);
      return NULL;
   }

   switch (pname) {
   case GL_DEBUG_CALLBACK_FUNCTION_ARB:
      val = (void *) debug->Callback;
      break;
   case GL_DEBUG_CALLBACK_USER_PARAM_ARB:
      val = (void *) debug->CallbackData;
      break;
   default:
      assert(!"unknown debug output param");
      val = NULL;
      break;
   }

   mtx_unlock(&ctx->DebugMutex);

   return val;
}

/**
 * Insert a debug message.  The mutex is assumed to be locked, and will be
 * unlocked by this call.
 */
static void
log_msg_locked_and_unlock(struct gl_context *ctx,
                          enum mesa_debug_source source,
                          enum mesa_debug_type type, GLuint id,
                          enum mesa_debug_severity severity,
                          GLint len, const char *buf)
{
   struct gl_debug_state *debug = ctx->Debug;

   if (!debug_is_message_enabled(debug, source, type, id, severity)) {
      _mesa_unlock_debug_state(ctx);
      return;
   }

   if (ctx->Debug->Callback) {
      GLenum gl_source = debug_source_enums[source];
      GLenum gl_type = debug_type_enums[type];
      GLenum gl_severity = debug_severity_enums[severity];
      GLDEBUGPROC callback = ctx->Debug->Callback;
      const void *data = ctx->Debug->CallbackData;

      /*
       * When ctx->Debug->SyncOutput is GL_FALSE, the client is prepared for
       * unsynchronous calls.  When it is GL_TRUE, we will not spawn threads.
       * In either case, we can call the callback unlocked.
       */
      _mesa_unlock_debug_state(ctx);
      callback(gl_source, gl_type, id, gl_severity, len, buf, data);
   }
   else {
      debug_log_message(ctx->Debug, source, type, id, severity, len, buf);
      _mesa_unlock_debug_state(ctx);
   }
}

/**
 * Log a client or driver debug message.
 */
static void
log_msg(struct gl_context *ctx, enum mesa_debug_source source,
        enum mesa_debug_type type, GLuint id,
        enum mesa_debug_severity severity, GLint len, const char *buf)
{
   struct gl_debug_state *debug = _mesa_lock_debug_state(ctx);

   if (!debug)
      return;

   log_msg_locked_and_unlock(ctx, source, type, id, severity, len, buf);
}


void
_mesa_init_errors(struct gl_context *ctx)
{
   mtx_init(&ctx->DebugMutex, mtx_plain);
}


void
_mesa_free_errors_data(struct gl_context *ctx)
{
   if (ctx->Debug) {
      debug_destroy(ctx->Debug);
      /* set to NULL just in case it is used before context is completely gone. */
      ctx->Debug = NULL;
   }

   mtx_destroy(&ctx->DebugMutex);
}


/**********************************************************************/
/** \name Diagnostics */
/*@{*/

static void
output_if_debug(const char *prefixString, const char *outputString,
                GLboolean newline)
{
   static int debug = -1;
   static FILE *fout = NULL;

   /* Init the local 'debug' var once.
    * Note: the _mesa_init_debug() function should have been called
    * by now so MESA_DEBUG_FLAGS will be initialized.
    */
   if (debug == -1) {
      /* If MESA_LOG_FILE env var is set, log Mesa errors, warnings,
       * etc to the named file.  Otherwise, output to stderr.
       */
      const char *logFile = _mesa_getenv("MESA_LOG_FILE");
      if (logFile)
         fout = fopen(logFile, "w");
      if (!fout)
         fout = stderr;
#ifdef DEBUG
      /* in debug builds, print messages unless MESA_DEBUG="silent" */
      if (MESA_DEBUG_FLAGS & DEBUG_SILENT)
         debug = 0;
      else
         debug = 1;
#else
      /* in release builds, be silent unless MESA_DEBUG is set */
      debug = _mesa_getenv("MESA_DEBUG") != NULL;
#endif
   }

   /* Now only print the string if we're required to do so. */
   if (debug) {
      fprintf(fout, "%s: %s", prefixString, outputString);
      if (newline)
         fprintf(fout, "\n");
      fflush(fout);

#if defined(_WIN32) && !defined(_WIN32_WCE)
      /* stderr from windows applications without console is not usually 
       * visible, so communicate with the debugger instead */ 
      {
         char buf[4096];
         _mesa_snprintf(buf, sizeof(buf), "%s: %s%s", prefixString, outputString, newline ? "\n" : "");
         OutputDebugStringA(buf);
      }
#endif
   }
}


/**
 * When a new type of error is recorded, print a message describing
 * previous errors which were accumulated.
 */
static void
flush_delayed_errors( struct gl_context *ctx )
{
   char s[MAX_DEBUG_MESSAGE_LENGTH];

   if (ctx->ErrorDebugCount) {
      _mesa_snprintf(s, MAX_DEBUG_MESSAGE_LENGTH, "%d similar %s errors", 
                     ctx->ErrorDebugCount,
                     _mesa_lookup_enum_by_nr(ctx->ErrorValue));

      output_if_debug("Mesa", s, GL_TRUE);

      ctx->ErrorDebugCount = 0;
   }
}


/**
 * Report a warning (a recoverable error condition) to stderr if
 * either DEBUG is defined or the MESA_DEBUG env var is set.
 *
 * \param ctx GL context.
 * \param fmtString printf()-like format string.
 */
void
_mesa_warning( struct gl_context *ctx, const char *fmtString, ... )
{
   char str[MAX_DEBUG_MESSAGE_LENGTH];
   va_list args;
   va_start( args, fmtString );  
   (void) _mesa_vsnprintf( str, MAX_DEBUG_MESSAGE_LENGTH, fmtString, args );
   va_end( args );
   
   if (ctx)
      flush_delayed_errors( ctx );

   output_if_debug("Mesa warning", str, GL_TRUE);
}


/**
 * Report an internal implementation problem.
 * Prints the message to stderr via fprintf().
 *
 * \param ctx GL context.
 * \param fmtString problem description string.
 */
void
_mesa_problem( const struct gl_context *ctx, const char *fmtString, ... )
{
    // LunarG DEL:
}


void
_mesa_gl_debug(struct gl_context *ctx,
               GLuint *id,
               enum mesa_debug_type type,
               enum mesa_debug_severity severity,
               const char *fmtString, ...)
{
   char s[MAX_DEBUG_MESSAGE_LENGTH];
   int len;
   va_list args;

   debug_get_id(id);

   va_start(args, fmtString);
   len = _mesa_vsnprintf(s, MAX_DEBUG_MESSAGE_LENGTH, fmtString, args);
   va_end(args);

   log_msg(ctx, MESA_DEBUG_SOURCE_API, type, *id, severity, len, s);
}


/**
 * Record an OpenGL state error.  These usually occur when the user
 * passes invalid parameters to a GL function.
 *
 * If debugging is enabled (either at compile-time via the DEBUG macro, or
 * run-time via the MESA_DEBUG environment variable), report the error with
 * _mesa_debug().
 * 
 * \param ctx the GL context.
 * \param error the error value.
 * \param fmtString printf() style format string, followed by optional args
 */
void
_mesa_error( struct gl_context *ctx, GLenum error, const char *fmtString, ... )
{
}

void
_mesa_error_no_memory(const char *caller)
{
}

/**
 * Report debug information.  Print error message to stderr via fprintf().
 * No-op if DEBUG mode not enabled.
 * 
 * \param ctx GL context.
 * \param fmtString printf()-style format string, followed by optional args.
 */
void
_mesa_debug( const struct gl_context *ctx, const char *fmtString, ... )
{
#ifdef DEBUG
   char s[MAX_DEBUG_MESSAGE_LENGTH];
   va_list args;
   va_start(args, fmtString);
   _mesa_vsnprintf(s, MAX_DEBUG_MESSAGE_LENGTH, fmtString, args);
   va_end(args);
   output_if_debug("Mesa", s, GL_FALSE);
#endif /* DEBUG */
   (void) ctx;
   (void) fmtString;
}


/**
 * Report debug information from the shader compiler via GL_ARB_debug_output.
 *
 * \param ctx GL context.
 * \param type The namespace to which this message belongs.
 * \param id The message ID within the given namespace.
 * \param msg The message to output. Need not be null-terminated.
 * \param len The length of 'msg'. If negative, 'msg' must be null-terminated.
 */
void
_mesa_shader_debug( struct gl_context *ctx, GLenum type, GLuint *id,
                    const char *msg, int len )
{
   enum mesa_debug_source source = MESA_DEBUG_SOURCE_SHADER_COMPILER;
   enum mesa_debug_severity severity = MESA_DEBUG_SEVERITY_HIGH;

   debug_get_id(id);

   if (len < 0)
      len = strlen(msg);

   /* Truncate the message if necessary. */
   if (len >= MAX_DEBUG_MESSAGE_LENGTH)
      len = MAX_DEBUG_MESSAGE_LENGTH - 1;

   log_msg(ctx, source, type, *id, severity, len, msg);
}

/*@}*/
